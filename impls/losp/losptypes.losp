from env import Env

class LospSymbol:
    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return isinstance(other, LospSymbol) and self.name == other.name

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return self.name

class LospVector:
    def __init__(self, items):
        if not isinstance(items, list):
            raise TypeError("LospVector items must be a list")
        self.items = items

    def __repr__(self):
        return f"Vector({self.items})"

    def __eq__(self, other):
        return isinstance(other, LospVector) and self.items == other.items

    def __getitem__(self, index):
        return self.items[index]

    def __len__(self):
        return len(self.items)

    def __iter__(self):
        return iter(self.items)

class LospHashMap:
    def __init__(self, items):
        if len(items) % 2 != 0:
            raise SyntaxError("Hash map literal must have an even number of forms")
        self.items = items

    def __repr__(self):
        return f"HashMap({self.items})"

class LospFunction:
    EVAL_fn = staticmethod(None)  # linked later

    def __init__(self, params, body, env=None, name=None):
        self.params = params
        self.body = body
        self.env = env
        self.name = name
        self.is_macro = False

    def __repr__(self):
        return f"#<function {self.name.name}>" if self.name else "#<function>"

    def __call__(self, *args):
        # Support variadic parameters using '&' in params list
        params = self.params
        if any(isinstance(p, LospSymbol) and p.name == "&" for p in params):
            amp_index = next(i for i, p in enumerate(params) if isinstance(p, LospSymbol) and p.name == "&")
            fixed_params = params[:amp_index]
            if amp_index + 1 >= len(params):
                raise TypeError("Function has '&' but no symbol after it")
            rest_param = params[amp_index + 1]

            if len(args) < len(fixed_params):
                raise TypeError(f"Expected at least {len(fixed_params)} args, got {len(args)}")

            local_env = Env(self.env)
            for p, a in zip(fixed_params, args[:len(fixed_params)]):
                local_env.set(p, a)
            local_env.set(rest_param, list(args[len(fixed_params):]))
        else:
            if len(args) != len(params):
                raise TypeError(f"Expected {len(params)} args, got {len(args)}")
            local_env = Env(self.env, binds=params, exprs=args)

        # Ensure body is iterable
        body_expressions = self.body if isinstance(self.body, list) else [self.body]

        result = None
        for expr in body_expressions:
            result = self.EVAL_fn(expr, local_env)
        return result
# losptypes.py

class LospNil:
    """Singleton object representing nil in LOSP."""
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(LospNil, cls).__new__(cls)
        return cls._instance

    def __repr__(self):
        return "nil"

    def __bool__(self):
        # nil is falsey
        return False
NIL = LospNil()

class LospAtom:
    def __init__(self, value):
        self.value = value

class LospList:
    def __init__(self, items=None):
        # items should be a list of Losp objects
        self.items = items if items else []

    def __repr__(self):
        # Custom string representation for printing
        return f"({' '.join(map(str, self.items))})"
