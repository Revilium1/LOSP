import reader, printer, core
from env import Env
from losptypes import LospSymbol, LospVector, LospHashMap, LospFunction, NIL


repl_env = Env()


for sym, fn in core.ns.items():
    repl_env.set(sym, fn)


repl_env.set(LospSymbol("nil"), NIL)
repl_env.set(LospSymbol("true"), True)
repl_env.set(LospSymbol("false"), False)


def is_truthy(val):
    return val is not False and val is not NIL


def EVAL(ast, env):
    while True:

        if isinstance(ast, LospSymbol):
            if ast.name.startswith(":"):
                return ast
            if ast.name == "nil":
                return NIL
            return env.get(ast)

        if isinstance(ast, list):
            if len(ast) == 0:
                return []

            first = ast[0]

            if isinstance(first, LospSymbol):

                if first.name == "def!":
                    val = EVAL(ast[2], env)
                    env.set(ast[1], val)
                    return val

                elif first.name == "let*":
                    bindings = ast[1]
                    body = ast[2]
                    env = Env(env)
                    for i in range(0, len(bindings), 2):
                        env.set(bindings[i], EVAL(bindings[i + 1], env))
                    ast = body
                    continue

                elif first.name == "do":
                    for expr in ast[1:-1]:
                        EVAL(expr, env)
                    ast = ast[-1]
                    continue

                elif first.name == "if":
                    cond = EVAL(ast[1], env)
                    if cond is False or cond is NIL:
                        ast = ast[3] if len(ast) > 3 else NIL
                    else:
                        ast = ast[2]
                    continue

                elif first.name == "fn*":
                    params = ast[1]
                    body = ast[2:]

                    fn = LospFunction(params=params, body=body, env=env)

                    fn.ast = body
                    fn.params = params
                    fn.env = env
                    fn.fn = fn

                    return fn



            evaluated = [EVAL(x, env) for x in ast]
            f = evaluated[0]
            args = evaluated[1:]

            if isinstance(f, LospFunction):
                env = Env(f.env, binds=f.params, exprs=args)

                for expr in f.ast[:-1]:
                    EVAL(expr, env)

                ast = f.ast[-1]
                continue


            elif callable(f):
                return f(*args)

            else:
                raise TypeError(f"{f} is not callable")


        if isinstance(ast, LospVector):
            return LospVector([EVAL(x, env) for x in ast.items])

        if isinstance(ast, LospHashMap):
            new_items = []
            for i in range(0, len(ast.items), 2):
                k = EVAL(ast.items[i], env)
                v = EVAL(ast.items[i + 1], env)
                new_items.extend([k, v])
            return LospHashMap(new_items)

        return ast

LospFunction.EVAL_fn = staticmethod(EVAL)


def READ(s):
    return reader.read_str(s)


def PRINT(val):
    return printer.pr_str(val)


def REP(s):
    return PRINT(EVAL(READ(s), repl_env))


if __name__ == "__main__":
    import sys

    while True:
        try:
            sys.stdout.write(REP(input("user> ")) + "\n")
            sys.stdout.flush()
        except EOFError:
            sys.stdout.write("\nGoodbye!\n")
            sys.stdout.flush()
            break
        except KeyError as e:
            sys.stdout.write(f"KeyError: {e}\n")
            sys.stdout.flush()
        except TypeError as e:
            sys.stdout.write(f"TypeError: {e}\n")
            sys.stdout.flush()
        except Exception as e:
            sys.stdout.write(f"Error: {e}\n")
            sys.stdout.flush()
