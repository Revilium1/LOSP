# core.losp
from losptypes import LospSymbol, LospFunction, NIL, LospVector, LospHashMap, LospAtom

# ---------------------------
# Printing
# ---------------------------

def prn(*args):
    import printer as _printer
    print(" ".join(_printer.pr_str(a, True) for a in args))
    return NIL

def println(*args):
    import printer as _printer
    print(" ".join(_printer.pr_str(a, False) for a in args))
    return NIL

def pr_str(*args):
    import printer as _printer
    if not args:
        return ""
    return " ".join(_printer.pr_str(a, True) for a in args)

# ---------------------------
# Lists
# ---------------------------

def list_fn(*args):
    return list(args)

def list_q(x):
    return isinstance(x, list)

def empty_q(x):
    return (isinstance(x, list) and len(x) == 0) or (isinstance(x, LospVector) and len(x) == 0)

def count(x):
    if x is None or x is NIL:
        return 0
    return len(x)

def first_fn(lst):
    if isinstance(lst, list) and lst:
        return lst[0]
    if isinstance(lst, LospVector) and len(lst.items) > 0:
        return lst.items[0]
    return NIL

def rest_fn(lst):
    if isinstance(lst, list) and lst:
        return lst[1:]
    if isinstance(lst, LospVector) and len(lst.items) > 0:
        return lst.items[1:]
    return []

def nth(coll, n):
    if not isinstance(n, int):
        raise TypeError("nth expects an integer index")

    if isinstance(coll, list):
        try:
            return coll[n]
        except IndexError:
            raise IndexError("nth index out of range")

    if isinstance(coll, LospVector):
        try:
            return coll.items[n]
        except IndexError:
            raise IndexError("nth index out of range")

    raise TypeError("nth expects a list or vector")

# ---------------------------
# Booleans
# ---------------------------

def not_fn(x):
    return x is False or x is NIL

def boolean_q(x):
    return x is True or x is False

def apply(f, *args):
    if len(args) == 0:
        raise TypeError("apply requires at least two arguments: a function and a list/vector")

    # Build list of arguments from prefix args and the last list/vector
    prefix = list(args[:-1])
    last = args[-1]

    if isinstance(last, list):
        combined = prefix + last
    elif isinstance(last, LospVector):
        combined = prefix + last.items
    else:
        raise TypeError("apply expects a list or vector as the last argument")

    # If f is a LospFunction, delegate to its __call__ which binds params and
    # evaluates the body. For native callables, just call with the combined args.
    if isinstance(f, LospFunction):
        return f(*combined)
    elif callable(f):
        return f(*combined)
    else:
        raise TypeError("apply only supports functions or macros")


def map(f, coll):
    """Applies the function `f` to each element of the collection `coll` and
    returns a plain list of results (per MAL test expectations)."""
    if isinstance(coll, list):
        return [f(x) for x in coll]
    elif isinstance(coll, LospVector):
        # Return a plain list, not a vector
        return [f(x) for x in coll.items]
    else:
        raise TypeError("map only supports lists or vectors")

# ---------------------------
# Strings
# ---------------------------

def str_fn(*args):
    def to_str(x):
        if x is NIL:
            return "nil"
        elif x is True:
            return "true"
        elif x is False:
            return "false"
        elif isinstance(x, str):
            return x
        elif isinstance(x, list):
            return "(" + " ".join(to_str(i) for i in x) + ")"
        elif isinstance(x, LospVector):
            return "[" + " ".join(to_str(i) for i in x.items) + "]"
        elif isinstance(x, LospHashMap):
            return "{" + " ".join(f"{to_str(x.items[i])} {to_str(x.items[i+1])}" for i in range(0, len(x.items), 2)) + "}"
        elif isinstance(x, LospFunction):
            return "#<function>"
        elif isinstance(x, LospAtom):
            return "(atom " + to_str(x.value) + ")"
        else:
            return str(x)
    return "".join(to_str(a) for a in args)

def read_string(s):
    import reader
    if not isinstance(s, str):
        raise TypeError("read-string expects a string")
    return reader.read_str(s)

def slurp(filename):
    if not isinstance(filename, str):
        raise TypeError("slurp expects a string")
    with open(filename, "r", encoding="utf-8") as f:
        return f.read()

# ---------------------------
# Comparison
# ---------------------------

def nil_q(value):
    return value is NIL

def true_q(value):
    return value is True

def false_q(value):
    return value is False

def symbol_q(value):
    return isinstance(value, LospSymbol) and (not value.name.startswith(':'))

def keyword_q(value):
    return isinstance(value, LospSymbol) and value.name.startswith(':')


def symbol_fn(s):
    if not isinstance(s, str):
        raise TypeError("symbol expects a string")
    return LospSymbol(s)


def keyword_fn(s):
    if isinstance(s, LospSymbol):
        if s.name.startswith(":"):
            return s
        else:
            return LospSymbol(":" + s.name)
    if not isinstance(s, str):
        raise TypeError("keyword expects a string or symbol")
    return LospSymbol(":" + s)


def sequential_q(x):
    return isinstance(x, list) or isinstance(x, LospVector)


def vector_q(x):
    return isinstance(x, LospVector)


def vector_fn(*args):
    return LospVector(list(args))


def map_q(x):
    return isinstance(x, LospHashMap)


def hash_map(*args):
    # Create a canonical hash map where later key occurrences override earlier ones
    if len(args) % 2 != 0:
        raise TypeError("hash-map expects an even number of arguments")
    items = []
    for i in range(0, len(args), 2):
        k = args[i]
        v = args[i+1]
        found = False
        for j in range(0, len(items), 2):
            if equal(items[j], k):
                items[j+1] = v
                found = True
                break
        if not found:
            items.extend([k, v])
    return LospHashMap(items)


def assoc(mp, *args):
    if not isinstance(mp, LospHashMap):
        raise TypeError("assoc expects a hash-map as first argument")
    if len(args) % 2 != 0:
        raise TypeError("assoc expects an even number of key/value pairs")
    items = list(mp.items)
    for i in range(0, len(args), 2):
        k = args[i]
        v = args[i+1]
        found = False
        for j in range(0, len(items), 2):
            if equal(items[j], k):
                items[j+1] = v
                found = True
                break
        if not found:
            items.extend([k, v])
    return LospHashMap(items)

def dissoc(mp, *keys):
    if mp is NIL:
        return mp
    if not isinstance(mp, LospHashMap):
        raise TypeError("dissoc expects a hash-map as first argument")
    items = []
    for i in range(0, len(mp.items), 2):
        k = mp.items[i]
        v = mp.items[i+1]
        skip = False
        for key in keys:
            if equal(k, key):
                skip = True
                break
        if not skip:
            items.extend([k, v])
    return LospHashMap(items)

def get_fn(mp, key, default=None):
    """Retrieve value for key from hash-map or default (default is NIL)."""
    if default is None:
        default = NIL
    if mp is NIL:
        return default
    if not isinstance(mp, LospHashMap):
        raise TypeError("get expects a hash-map as first argument")
    for i in range(0, len(mp.items), 2):
        if equal(mp.items[i], key):
            return mp.items[i+1]
    return default


def contains_q(mp, key):
    """Return True if mp contains key."""
    if mp is NIL:
        return False
    if not isinstance(mp, LospHashMap):
        raise TypeError("contains? expects a hash-map as first argument")
    for i in range(0, len(mp.items), 2):
        if equal(mp.items[i], key):
            return True
    return False


def keys(mp):
    if mp is NIL:
        return []
    if not isinstance(mp, LospHashMap):
        raise TypeError("keys expects a hash-map as first argument")
    return [mp.items[i] for i in range(0, len(mp.items), 2)]


def vals(mp):
    if mp is NIL:
        return []
    if not isinstance(mp, LospHashMap):
        raise TypeError("vals expects a hash-map as first argument")
    return [mp.items[i+1] for i in range(0, len(mp.items), 2)]


def equal(a, b):
    # nil comparison
    if a is NIL and b is NIL:
        return True

    # both plain Python lists
    if isinstance(a, list) and isinstance(b, list):
        return len(a) == len(b) and all(equal(x, y) for x, y in zip(a, b))

    # both LospVector
    if isinstance(a, LospVector) and isinstance(b, LospVector):
        return len(a.items) == len(b.items) and all(equal(x, y) for x, y in zip(a.items, b.items))

    # cross-type: list vs LospVector
    if isinstance(a, list) and isinstance(b, LospVector):
        return len(a) == len(b.items) and all(equal(x, y) for x, y in zip(a, b.items))
    if isinstance(a, LospVector) and isinstance(b, list):
        return len(a.items) == len(b) and all(equal(x, y) for x, y in zip(a.items, b))

    # hash maps (compare key/value pairs, order-insensitive)
    if isinstance(a, LospHashMap) and isinstance(b, LospHashMap):
        if len(a.items) != len(b.items):
            return False
        # For each key in a, find equal key in b and compare values
        for i in range(0, len(a.items), 2):
            key = a.items[i]
            val = a.items[i+1]
            found = False
            for j in range(0, len(b.items), 2):
                if equal(key, b.items[j]):
                    if not equal(val, b.items[j+1]):
                        return False
                    found = True
                    break
            if not found:
                return False
        return True

    # fallback to Python equality, but only for same types
    if type(a) != type(b):
        return False
    return a == b

def lt(a, b): return a < b
def lte(a, b): return a <= b
def gt(a, b): return a > b
def gte(a, b): return a >= b

# ---------------------------
# Arithmetic
# ---------------------------

def add(a, b): return a + b
def sub(a, b): return a - b
def mul(a, b): return a * b
def div(a, b): return int(a / b)

# ---------------------------
# Atoms
# ---------------------------

# Atoms
def atom_fn(x):
    """Creates a new LospAtom pointing to x."""
    from losptypes import LospAtom
    return LospAtom(x)

def atom_q(x):
    """Returns True if x is a LospAtom."""
    from losptypes import LospAtom
    return isinstance(x, LospAtom)

def deref(atom):
    """Returns the value inside an atom."""
    from losptypes import LospAtom
    if not isinstance(atom, LospAtom):
        raise TypeError("deref expects an atom")
    return atom.value

def reset_bang(atom, value):
    """Sets the atom's value to value and returns value."""
    from losptypes import LospAtom
    if not isinstance(atom, LospAtom):
        raise TypeError("reset! expects an atom")
    atom.value = value
    return value

def swap_bang(atom, fn, *args):
    """Updates an atom's value using fn and optional arguments."""
    from losptypes import LospAtom

    if not isinstance(atom, LospAtom):
        raise TypeError("swap! expects an atom")

    # Python function
    if callable(fn):
        new_val = fn(atom.value, *args)

    # LospFunction (MAL function)
    elif hasattr(fn, 'fn'):
        # Build AST: (fn atom.value arg1 arg2 ...)
        call_ast = [fn, atom.value] + list(args)
        # You **must** provide EVAL and environment here
        # Typically, swap! is called inside your REPL / EVAL loop, so:
        # new_val = EVAL(call_ast, current_env)
        # We'll pass in the environment at call-time via a wrapper
        raise TypeError("MAL functions in swap! require env-aware wrapper")

    else:
        raise TypeError("swap! first arg must be an atom and second arg must be callable")

    atom.value = new_val
    return new_val

# quotes 
def cons(x, lst):
    if isinstance(lst, list):
        return [x] + lst  # Prepend x to a Python list
    elif isinstance(lst, LospVector):
        # Per MAL tests, cons with a vector should return a list, not a vector
        return [x] + lst.items
    else:
        raise TypeError("cons expects a list or LospVector as the second argument")


def concat(*args):
    result = []
    for lst in args:
        if isinstance(lst, list):
            result.extend(lst)  # Append all elements of lst
        elif isinstance(lst, LospVector):
            result.extend(lst.items)  # Append all elements of LospVector
        else:
            raise TypeError("concat expects list or LospVector arguments")
    return result  # Return concatenated list


def macro_q(x):
    """Returns True if x is a macro (a LospFunction with is_macro flag)."""
    return isinstance(x, LospFunction) and getattr(x, 'is_macro', False)


def vec_fn(x):
    """Convert a list to a LospVector or return a LospVector unchanged."""
    if isinstance(x, list):
        return LospVector(x)
    if isinstance(x, LospVector):
        return x
    raise TypeError("vec expects a list or LospVector as argument")


def quasiquote(ast):
    # Case 1: ast is a list starting with "unquote"
    if isinstance(ast, list) and len(ast) > 0 and isinstance(ast[0], LospSymbol):
        if ast[0].name == "unquote":
            return ast[1]

    # Case 2: ast is a list
    if isinstance(ast, list):
        result = []
        for elt in reversed(ast):
            if isinstance(elt, list) and len(elt) > 0 and isinstance(elt[0], LospSymbol):
                if elt[0].name == "splice-unquote":
                    # (concat <elt[1]> <result>)
                    result = [LospSymbol("concat"), elt[1], result]
                    continue
            # Otherwise, (cons (quasiquote elt) result)
            result = [LospSymbol("cons"), quasiquote(elt), result]
        return result

    # Case 2b: ast is a vector -> produce (vec <list-form>)
    if isinstance(ast, LospVector):
        result = []
        for elt in reversed(ast.items):
            if isinstance(elt, list) and len(elt) > 0 and isinstance(elt[0], LospSymbol):
                if elt[0].name == "splice-unquote":
                    result = [LospSymbol("concat"), elt[1], result]
                    continue
            result = [LospSymbol("cons"), quasiquote(elt), result]
        return [LospSymbol("vec"), result]

    # Case 3: ast is a map or symbol
    if isinstance(ast, (LospSymbol, LospHashMap)):
        return [LospSymbol("quote"), ast]

    # Case 4: everything else (numbers, strings, etc.)
    return ast

# ---------------------------
# Core namespace
# ---------------------------

ns = {
    # Numeric
    LospSymbol('+'): add,
    LospSymbol('-'): sub,
    LospSymbol('*'): mul,
    LospSymbol('/'): div,

    # Printing
    LospSymbol('prn'): prn,
    LospSymbol('pr-str'): pr_str,
    LospSymbol('println'): println,

    # Lists
    LospSymbol('list'): list_fn,
    LospSymbol('list?'): list_q,
    LospSymbol('empty?'): empty_q,
    LospSymbol('count'): count,
    LospSymbol('first'): first_fn,
    LospSymbol('rest'): rest_fn,
    LospSymbol('nth'): nth,

    # Strings
    LospSymbol('str'): str_fn,
    LospSymbol('read-string'): read_string,
    LospSymbol('slurp'): slurp,
    LospSymbol('symbol'): symbol_fn,
    LospSymbol('keyword'): keyword_fn,

    # Comparison
    LospSymbol('='): equal,
    LospSymbol('<'): lt,
    LospSymbol('<='): lte,
    LospSymbol('>'): gt,
    LospSymbol('>='): gte,
    LospSymbol('not'): not_fn,
    LospSymbol('boolean?'): boolean_q,
    LospSymbol('nil?'): nil_q,
    LospSymbol('true?'): true_q,
    LospSymbol('false?'): false_q,
    LospSymbol('symbol?'): symbol_q,
    LospSymbol('keyword?'): keyword_q,
    LospSymbol('sequential?'): sequential_q,

    # Atoms
    LospSymbol('atom'): atom_fn,
    LospSymbol('atom?'): atom_q,
    LospSymbol('deref'): deref,
    LospSymbol('reset!'): reset_bang,
    LospSymbol('swap!'): swap_bang,

    LospSymbol("apply"): apply,
    LospSymbol("map"): map,

    # Quotes
    LospSymbol('cons'): cons,
    LospSymbol('concat'): concat,
    LospSymbol('vec'): vec_fn,
    LospSymbol('quasiquote'): quasiquote,
    LospSymbol('macro?'): macro_q,
    LospSymbol('vector?'): vector_q,
    LospSymbol('vector'): vector_fn,
    LospSymbol('map?'): map_q,
    LospSymbol('hash-map'): hash_map,
    LospSymbol('assoc'): assoc,
    LospSymbol('get'): get_fn,
    LospSymbol('contains?'): contains_q,
    LospSymbol('keys'): keys,
    LospSymbol('vals'): vals,
    LospSymbol('dissoc'): dissoc,
}
