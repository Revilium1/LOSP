# core.losp
from losptypes import LospSymbol, LospFunction, NIL, LospVector, LospHashMap, LospAtom

# ---------------------------
# Printing
# ---------------------------

def prn(*args):
    import printer as _printer
    print(" ".join(_printer.pr_str(a, True) for a in args))
    return NIL

def println(*args):
    import printer as _printer
    print(" ".join(_printer.pr_str(a, False) for a in args))
    return NIL

def pr_str(*args):
    import printer as _printer
    if not args:
        return ""
    return " ".join(_printer.pr_str(a, True) for a in args)

# ---------------------------
# Lists
# ---------------------------

def list_fn(*args):
    return list(args)

def list_q(x):
    return isinstance(x, list)

def empty_q(x):
    return (isinstance(x, list) and len(x) == 0) or (isinstance(x, LospVector) and len(x) == 0)

def count(x):
    if x is None or x is NIL:
        return 0
    return len(x)

def first_fn(lst):
    if isinstance(lst, list) and lst:
        return lst[0]
    return NIL

def rest_fn(lst):
    if isinstance(lst, list) and lst:
        return lst[1:]
    return []

# ---------------------------
# Booleans
# ---------------------------

def not_fn(x):
    return x is False or x is NIL

def boolean_q(x):
    return x is True or x is False

# ---------------------------
# Strings
# ---------------------------

def str_fn(*args):
    def to_str(x):
        if x is NIL:
            return "nil"
        elif x is True:
            return "true"
        elif x is False:
            return "false"
        elif isinstance(x, str):
            return x
        elif isinstance(x, list):
            return "(" + " ".join(to_str(i) for i in x) + ")"
        elif isinstance(x, LospVector):
            return "[" + " ".join(to_str(i) for i in x.items) + "]"
        elif isinstance(x, LospHashMap):
            return "{" + " ".join(f"{to_str(x.items[i])} {to_str(x.items[i+1])}" for i in range(0, len(x.items), 2)) + "}"
        elif isinstance(x, LospFunction):
            return "#<function>"
        elif isinstance(x, LospAtom):
            return "(atom " + to_str(x.value) + ")"
        else:
            return str(x)
    return "".join(to_str(a) for a in args)

def read_string(s):
    import reader
    if not isinstance(s, str):
        raise TypeError("read-string expects a string")
    return reader.read_str(s)

def slurp(filename):
    if not isinstance(filename, str):
        raise TypeError("slurp expects a string")
    with open(filename, "r", encoding="utf-8") as f:
        return f.read()

# ---------------------------
# Comparison
# ---------------------------

def equal(a, b):
    # nil comparison
    if a is NIL and b is NIL:
        return True

    # both plain Python lists
    if isinstance(a, list) and isinstance(b, list):
        return len(a) == len(b) and all(equal(x, y) for x, y in zip(a, b))

    # both LospVector
    if isinstance(a, LospVector) and isinstance(b, LospVector):
        return len(a.items) == len(b.items) and all(equal(x, y) for x, y in zip(a.items, b.items))

    # cross-type: list vs LospVector
    if isinstance(a, list) and isinstance(b, LospVector):
        return len(a) == len(b.items) and all(equal(x, y) for x, y in zip(a, b.items))
    if isinstance(a, LospVector) and isinstance(b, list):
        return len(a.items) == len(b) and all(equal(x, y) for x, y in zip(a.items, b))

    # hash maps (compare key/value pairs pairwise)
    if isinstance(a, LospHashMap) and isinstance(b, LospHashMap):
        if len(a.items) != len(b.items):
            return False
        for i in range(0, len(a.items), 2):
            if not (equal(a.items[i], b.items[i]) and equal(a.items[i+1], b.items[i+1])):
                return False
        return True

    # fallback to Python equality, but only for same types
    if type(a) != type(b):
        return False
    return a == b

def lt(a, b): return a < b
def lte(a, b): return a <= b
def gt(a, b): return a > b
def gte(a, b): return a >= b

# ---------------------------
# Arithmetic
# ---------------------------

def add(a, b): return a + b
def sub(a, b): return a - b
def mul(a, b): return a * b
def div(a, b): return int(a / b)

# ---------------------------
# Atoms
# ---------------------------

# Atoms
def atom_fn(x):
    """Creates a new LospAtom pointing to x."""
    from losptypes import LospAtom
    return LospAtom(x)

def atom_q(x):
    """Returns True if x is a LospAtom."""
    from losptypes import LospAtom
    return isinstance(x, LospAtom)

def deref(atom):
    """Returns the value inside an atom."""
    from losptypes import LospAtom
    if not isinstance(atom, LospAtom):
        raise TypeError("deref expects an atom")
    return atom.value

def reset_bang(atom, value):
    """Sets the atom's value to value and returns value."""
    from losptypes import LospAtom
    if not isinstance(atom, LospAtom):
        raise TypeError("reset! expects an atom")
    atom.value = value
    return value

def swap_bang(atom, fn, *args):
    """Updates an atom's value using fn and optional arguments."""
    from losptypes import LospAtom

    if not isinstance(atom, LospAtom):
        raise TypeError("swap! expects an atom")

    # Python function
    if callable(fn):
        new_val = fn(atom.value, *args)

    # LospFunction (MAL function)
    elif hasattr(fn, 'fn'):
        # Build AST: (fn atom.value arg1 arg2 ...)
        call_ast = [fn, atom.value] + list(args)
        # You **must** provide EVAL and environment here
        # Typically, swap! is called inside your REPL / EVAL loop, so:
        # new_val = EVAL(call_ast, current_env)
        # We'll pass in the environment at call-time via a wrapper
        raise TypeError("MAL functions in swap! require env-aware wrapper")

    else:
        raise TypeError("swap! first arg must be an atom and second arg must be callable")

    atom.value = new_val
    return new_val

# quotes 
def cons(x, lst):
    if isinstance(lst, list):
        return [x] + lst  # Prepend x to a Python list
    elif isinstance(lst, LospVector):
        # Per MAL tests, cons with a vector should return a list, not a vector
        return [x] + lst.items
    else:
        raise TypeError("cons expects a list or LospVector as the second argument")


def concat(*args):
    result = []
    for lst in args:
        if isinstance(lst, list):
            result.extend(lst)  # Append all elements of lst
        elif isinstance(lst, LospVector):
            result.extend(lst.items)  # Append all elements of LospVector
        else:
            raise TypeError("concat expects list or LospVector arguments")
    return result  # Return concatenated list


def vec_fn(x):
    """Convert a list to a LospVector or return a LospVector unchanged."""
    if isinstance(x, list):
        return LospVector(x)
    if isinstance(x, LospVector):
        return x
    raise TypeError("vec expects a list or LospVector as argument")


def quasiquote(ast):
    # Case 1: ast is a list starting with "unquote"
    if isinstance(ast, list) and len(ast) > 0 and isinstance(ast[0], LospSymbol):
        if ast[0].name == "unquote":
            return ast[1]

    # Case 2: ast is a list
    if isinstance(ast, list):
        result = []
        for elt in reversed(ast):
            if isinstance(elt, list) and len(elt) > 0 and isinstance(elt[0], LospSymbol):
                if elt[0].name == "splice-unquote":
                    # (concat <elt[1]> <result>)
                    result = [LospSymbol("concat"), elt[1], result]
                    continue
            # Otherwise, (cons (quasiquote elt) result)
            result = [LospSymbol("cons"), quasiquote(elt), result]
        return result

    # Case 2b: ast is a vector -> produce (vec <list-form>)
    if isinstance(ast, LospVector):
        result = []
        for elt in reversed(ast.items):
            if isinstance(elt, list) and len(elt) > 0 and isinstance(elt[0], LospSymbol):
                if elt[0].name == "splice-unquote":
                    result = [LospSymbol("concat"), elt[1], result]
                    continue
            result = [LospSymbol("cons"), quasiquote(elt), result]
        return [LospSymbol("vec"), result]

    # Case 3: ast is a map or symbol
    if isinstance(ast, (LospSymbol, LospHashMap)):
        return [LospSymbol("quote"), ast]

    # Case 4: everything else (numbers, strings, etc.)
    return ast


# ---------------------------
# Core namespace
# ---------------------------

ns = {
    # Numeric
    LospSymbol('+'): add,
    LospSymbol('-'): sub,
    LospSymbol('*'): mul,
    LospSymbol('/'): div,

    # Printing
    LospSymbol('prn'): prn,
    LospSymbol('pr-str'): pr_str,
    LospSymbol('println'): println,

    # Lists
    LospSymbol('list'): list_fn,
    LospSymbol('list?'): list_q,
    LospSymbol('empty?'): empty_q,
    LospSymbol('count'): count,
    LospSymbol('first'): first_fn,
    LospSymbol('rest'): rest_fn,

    # Strings
    LospSymbol('str'): str_fn,
    LospSymbol('read-string'): read_string,
    LospSymbol('slurp'): slurp,

    # Comparison
    LospSymbol('='): equal,
    LospSymbol('<'): lt,
    LospSymbol('<='): lte,
    LospSymbol('>'): gt,
    LospSymbol('>='): gte,
    LospSymbol('not'): not_fn,
    LospSymbol('boolean?'): boolean_q,

    # Atoms
    LospSymbol('atom'): atom_fn,
    LospSymbol('atom?'): atom_q,
    LospSymbol('deref'): deref,
    LospSymbol('reset!'): reset_bang,
    LospSymbol('swap!'): swap_bang,

    # Quotes
    LospSymbol('cons'): cons,
    LospSymbol('concat'): concat,
    LospSymbol('vec'): vec_fn,
    LospSymbol('quasiquote'): quasiquote,
}
